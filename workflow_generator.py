from typing import List, Dict, Any, Optional
from enum import Enum
from pydantic import BaseModel, Field
from huggingface_gemma import HuggingFaceGemmaClient
import json

class ErrorPolicy(str, Enum):
    IGNORE = "IGNORE"
    RAISE = "RAISE"
    RETRY = "RETRY"

class ParameterSource(str, Enum):
    HUMAN_INPUT = "human_input"
    TASK_CONFIG = "task_config"
    SYSTEM_GENERATED = "system_generated"

class Parameter(BaseModel):
    name: str
    type: str
    description: str
    source: ParameterSource
    value: Optional[Any] = None

class Output(BaseModel):
    name: str
    type: str
    description: str

class Task(BaseModel):
    name: str
    instructions: str
    input_parameters: List[Parameter]
    expected_output: List[Output]
    dependencies: List[str] = []
    error_policy: ErrorPolicy
    tool: Optional[str] = None

class Workflow(BaseModel):
    name: str
    tasks: List[Task]
    domain: str
    subdomain: str

class GemmaWorkflowGenerator:
    def __init__(self, api_key: str = None):
        """
        Initialize workflow generator with Hugging Face Gemma client.
        
        Args:
            api_key: Hugging Face API key (optional if set in environment)
        """
        self.client = HuggingFaceGemmaClient(api_key)

    def _create_prompt(self, human_input: str, conversation_history: List[Dict[str, Any]]) -> str:
        """
        Create a formatted prompt for the Gemma model.
        """
        base_prompt = """
        # Purpose
        Generate a detailed workflow for given human input and conversation history with the following structure:

        # Workflow Structure
        A workflow is uniquely identified by its name. It consists of a sequence of blocks, which can be of the following types:
                TASK: Represents the smallest unit of work within a workflow.

        Task: A task is defined by the following attributes:
            1.) name: A unique identifier for the task (snakecase, first-order and readable)
            2.) instructions: Clear and concise insturctions related task execution.
            3.) input_parameters: A list of parameters required to execute the task.
                    a.) name: name of the input parameter
                    b.) type: datatype of the input parameter
                    c.) description: description of the input parameter
                    d.) source: source of the input parameter one of these - human_input, task_config, system_generated
                    e.) value: value of the source
                        i.) human_input: value of the input parameter is provided by the human
                        ii.) task_config: value of the input parameter is provided by the previous tasks
                        iii.) system_generated: value of the input parameter is generated by the system during the task execution
            4.) expected_output: A list of parameters that the task should produce as output (defined with JSON schema). It should contain:
                    a.) name: Name of the output variable
                    b.) type: DataType of the output variable
                    c.) description: Description of the output and its variable
            5.) dependencies: A list of task IDs that must be completed before this task can be executed.
            6.) error_policy: A strategy for handling errors during task execution (e.g., IGNORE, RAISE, RETRY).
            7.) tool: Id of the tool that will be used for executing the task, if applicable. Tools are first-order functions that accept input parameters and produce output parameters. (Only select from the available tools, DO NOT assume any other tools)

        # Knowledge
        {'tools': [], 'user': User(id=1, organization_id=16, team_id=None, permissions=['delete:workflows', 'delete:tools', 'delete:workflow_instances', 'delete:entities', 'delete:tasks'], conversation_id='6bfddd5c-ab71-443c-b924-84c9c59fc483')}

        # Response
        Respond with the json structure as mentioned above

        Note: Be as extensive and non-abstract as possible when generating data for the given domain/sub-domain. Follow first-order principle and domain-driven entities.
        """
        
        # history_str = "\n".join([
        #     f"User: {msg['content']}" 
        #     for msg in conversation_history
        # ])
        
        return f"{base_prompt}\n\nInput: {human_input}\n\nHistory:\n{conversation_history}"

    def generate_workflow(self, 
                         human_input: str, 
                         conversation_history: List[Dict[str, Any]]) -> Dict:
        """
        Generate workflow using Gemma-27B.
        """
        prompt = self._create_prompt(human_input, conversation_history)
        response = self.client.generate_response(prompt)
        #print(response)
        
        try:
            workflow = self._parse_workflow(response)
            if self.validate_workflow(workflow):
                return workflow
            else:
                raise ValueError("Generated workflow failed validation")
        except Exception as e:
            raise Exception(f"Error processing workflow: {str(e)}")

    def _parse_workflow(self, model_response: str) -> Workflow:
        """Parse the model's response into a Workflow object."""
        try:
            workflow_dict = json.loads(model_response)
            return Workflow(**workflow_dict)
        except Exception as e:
            raise Exception(f"Error parsing workflow JSON: {str(e)}")

    def validate_workflow(self, workflow: Workflow) -> bool:
        """Validate the generated workflow."""
        try:
            # Validate unique task names
            task_names = set()
            for task in workflow.tasks:
                if task.name in task_names:
                    return False
                task_names.add(task.name)

            # Validate dependencies exist
            all_tasks = {task.name for task in workflow.tasks}
            for task in workflow.tasks:
                if not all(dep in all_tasks for dep in task.dependencies):
                    return False

            return True
        except Exception:
            return False